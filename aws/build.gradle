import com.amazonaws.services.lambda.AWSLambda
import com.amazonaws.services.lambda.model.InvocationType
import com.amazonaws.services.lambda.model.InvokeRequest
import com.amazonaws.services.lambda.model.LogType
import jp.classmethod.aws.gradle.lambda.AWSLambdaInvokeTask
import jp.classmethod.aws.gradle.lambda.AWSLambdaMigrateFunctionTask
import jp.classmethod.aws.gradle.lambda.AWSLambdaPluginExtension

buildscript {
    repositories {
        jcenter()
        mavenLocal()
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath "jp.classmethod.aws:gradle-aws-plugin:0.35"
    }
}

group 'beam'
version '0.5.0-SNAPSHOT'

apply plugin: "base"
apply plugin: "jp.classmethod.aws.lambda"

aws {
    profileName = "default"
    region = "us-east-2"
}

lambda {
    region = "us-west-2"
}

task deploy(type: AWSLambdaInvokeTask) {
    doFirst {
        if (!project.hasProperty('runName')) {
            throw new GradleException('Please name the run by specifying `runName` argument. e.g; ./gradlew deploy -PrunName=sfbay-performance-run')
        }

        switch (project.findProperty('deployMode')) {
            case 'config':
                if (!project.hasProperty('beamConfigs') && !project.hasProperty(getCurrentGitBranch() + '.configs')) {
                    throw new GradleException('beamConfigs is required to deploy config run.')
                }
                break
            case 'experiment':
                if (!project.hasProperty('beamExperiments') && !project.hasProperty(getCurrentGitBranch() + '.experiments')) {
                    throw new GradleException('beamExperiments is required to deploy experement.')
                }
                break
            case 'execute':
                if (!project.hasProperty('executeClass') || !project.hasProperty('executeArgs')) {
                    throw new GradleException('executeClass and executeArgs are required to deploy execute.')
                }
                break
            default:
                throw new GradleException('Please provide a valid deployMode.')
                break
        }
    }

    def pload = """{
  "title": "${project.findProperty('runName')}",
  "branch": "${project.findProperty('beamBranch') ?: getCurrentGitBranch()}",
  "commit": "${beamCommit ?: 'HEAD'}",
  "deploy_mode": "${project.findProperty('deployMode')}",
  "configs": "${project.findProperty('beamConfigs') ?: project.findProperty(getCurrentGitBranch() + '.configs')}",
  "experiments": "${
        project.findProperty('beamExperiments') ?: project.findProperty(getCurrentGitBranch() + '.experiments')
    }",
  "execute_class": "${project.findProperty('executeClass')}",
  "execute_args": "${project.findProperty('executeArgs')}",
  "max_ram": "${maxRAM ?: '2g'}",
  "batch": "$beamBatch",
  "s3_publish": "${project.findProperty('s3Backup') ?: true}",
  "instance_type": "${project.findProperty('instanceType') ?: defaultInstanceType}",
  "region": "$region",
  "shutdown_wait": "$shutdownWait",
  "shutdown_behaviour": "$shutdownBehaviour",
  "command": "deploy"
}"""

    functionName = "simulateBeam"
    invocationType = InvocationType.RequestResponse
    payload = pload

    doLast {
        println pload
        println new String(invokeResult.payload.array(), "UTF-8")
    }
}

task start(type: AWSLambdaInvokeTask) {
    doFirst {
        checkInstanceId()
    }

    functionName = "ec2StartStop"
    invocationType = InvocationType.RequestResponse
    payload = buildPayload("start")

    doLast {
        printResult(payload, invokeResult)
    }
}

task stop(type: AWSLambdaInvokeTask) {
    doFirst {
        checkInstanceId()
    }

    functionName = "ec2StartStop"
    invocationType = InvocationType.RequestResponse
    payload = buildPayload("stop")

    doLast {
        printResult(payload, invokeResult)
    }
}

task terminate(type: AWSLambdaInvokeTask) {
    doFirst {
        checkInstanceId()
    }

    functionName = "simulateBeam"
    invocationType = InvocationType.RequestResponse
    payload = buildPayload("terminate")

    doLast {
        printResult(payload, invokeResult)
    }
}

def checkInstanceId() {
    if (!project.hasProperty('instanceIds')) {
        throw new GradleException('Please specify instance ids using argument `instanceIds`.')
    }
}

def buildPayload(command) {
    println "command:" + command
    return """{
  "instance_ids": "${project.findProperty('instanceIds')}",
  "region": "$region",
  "command": "$command"
}"""
}

def printResult(pload, result) {
    println pload
    println new String(result.payload.array(), "UTF-8")
}

def getCurrentGitBranch() {
    def gitBranch = "$defaultBranch"
    try {
        def workingDir = new File("${project.projectDir}")
        def result = 'git rev-parse --abbrev-ref HEAD'.execute(null, workingDir)
        result.waitFor()
        if (result.exitValue() == 0) {
            gitBranch = result.text.trim()
        }
    } catch (e) {
    }
    return gitBranch
}

task installPythonDependency(type: Exec) {
    workingDir 'src/main/python/eksStartStop/package'
    executable 'python'
    args '-m', 'pip', 'install', '-r', 'requirements.txt', '-t', '.'
}

task packageEksCreationFunction(dependsOn: [installPythonDependency], type: Zip) {
    from fileTree('src/main/python/eksStartStop/package')
    from ('src/main/python/eksStartStop/lambda_function.py')
    include '**/'
    archiveFileName = 'function.zip'
}

task packageEksCheckFunction(type: Zip) {
    from fileTree('src/main/python/eksDescribe')
    include '**/'
    archiveFileName = 'function.zip'
}

task packageRunNodeFunction(type: Zip) {
    from fileTree('src/main/python/runNodes')
    include '**/'
    archiveFileName = 'function.zip'
}

task eksCreationFunction(dependsOn: packageEksCreationFunction, type: AWSLambdaMigrateFunctionTask) {
    functionName = "eksCreation"
    role = "arn:aws:iam::340032650202:role/BeamEksDeployment"
    functionDescription = "Beam Cluster Simulation Environment"
    zipFile = packageEksCreationFunction.archivePath
    handler = "lambda_function.lambda_handler"
    runtime = "Python27"
    timeout = 900
    memorySize = 256
    environment = [
            REGION: "us-west-2",
    ]
}

task eksDescribeFunction(dependsOn: packageEksCheckFunction, type: AWSLambdaMigrateFunctionTask) {
    functionName = "eksDescribe"
    role = "arn:aws:iam::340032650202:role/BeamEksDeployment"
    functionDescription = "Beam Cluster Simulation Output"
    zipFile = packageEksCheckFunction.archivePath
    handler = "lambda_function.lambda_handler"
    runtime = "Python27"
    environment = [
            REGION: "us-west-2"
    ]
}

task runEKSNodesFunction(dependsOn: packageRunNodeFunction, type: AWSLambdaMigrateFunctionTask) {
    functionName = "runNodes"
    role = "arn:aws:iam::340032650202:role/BeamEksDeployment"
    functionDescription = "Beam Cluster Worker Nodes"
    zipFile = packageRunNodeFunction.archivePath
    handler = "lambda_function.lambda_handler"
    runtime = "Python27"
    timeout = 300
    memorySize = 256
    environment = [
            REGION: "us-west-2",
            SYSTEM_INSTANCE: "t3.nano"
    ]
}